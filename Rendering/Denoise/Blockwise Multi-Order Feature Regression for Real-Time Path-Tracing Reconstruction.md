# Blockwise Multi-Order Feature Regression for Real-Time Path-Tracing Reconstruction

## Introduction

In this article we propose a new regression-based reconstruction pipeline optimized for 1 spp input images that runs in real time on desktop GPUs.

## Reconstruction Pipeline

The proposed reconstruction pipeline can be divided into three main phases:

-   preprocessing
-   feature fitting
-   post-processing

### Input

The input is a 1spp path-traced frame and its accompanying feature buffers. The 1 spp frames are generated by using a rasterizer for producing the primary rays and feature buffers.

Before inputting the 1 spp input to our post-processing pipeline, we remove the first-bounce albedo from it, which is a common practice. However, unlike other methods, we do not separate the direct and indirect illumination because doing so did not display major improvement in the results.

### Preprocessing

The preprocessing phase consists of temporal accumulation of the noisy data, which reprojects the previous accumulated data to the new camera frame. We compute an EMA and mix 80% of the history data with 20% of the current frame data. However, we only do so when the cumulative moving average weight of the new sample is less than 20%.

Computing the cumulative moving average requires that we store and update the sample count of every pixel. Since we only do so when the sample count is small, the sample count can be store using just a few bits.

We perform bilinear sampling of the history data, and discarding pixels do not affect our pixel brightness.

### Blockwise Multi-Order Feature Regression (BMFR)

We dissect the whole frame into multiple non-overlapping tiles and perform phase II on each tile separately. Let $F=[F_1,\dots,F_N]$ denote a set of available noise-free feature buffers, such as the world-space positions and shading normals. These buffers can be side products of path tracing, or artificially created ones like gradients. Each buffer in $F$ has the same resolution as the noisy frame. We consider an *extended* set $T$ of $M$ feature buffers:
$$
T=[F^{\gamma_1}_{n_1},\dots.F^{\gamma_m}_{n_m},\dots,F^{\gamma_M}_{n_M}]
$$
The first buffer is a constant buffer $F^0_{n_1}=\mathbf{1}$.

Denoting by $\Omega_{i,j}$ the set of absolute coordinates of the pixels within a tile at position $(i,j)$, the BMFR problem can be formulated like a standard least-square expression with respect to the multi-order features $T$ as
$$
\hat{\alpha}^{(c)}=\text{argmin}_{\alpha^{(c)}\in\R^M}\sum_{(p,q)\in\Omega_{i,j}}\left(Z^{(c)}(p,q)-\sum_{m=1}^M\alpha_m^{(c)}F_{n_m}^{\gamma_m}(p,q)\right)^2
$$
The estimate of the noise-free scene $Y$ for channel $c$ and block $\Omega_{i,j}$ is
$$
\hat{Y}^{(c)}(p,q)=\sum_{m=1}^M\hat{\alpha}_m^{(c)}F_{n_m}^{\gamma_m}(p,q)
$$

### Feature Fitting with Stochastic Regularization

We reshape the $M$ blockwise feature buffers as column vectors of length $W$, where $W$ is the number of pixels in the block, and let $T$ be the $W\times M$ matrix obtained by horizontal concatenation of such column vectors.

Further, we augment $T$ with $z^{(c)}$, to get the $W\times(M+1)$ matrix. Assuming that $\widetilde{T}^{(c)}$ is full rank, the Householder QR factorization yields an $(M+1)\times(M+1)$ upper triangular matrix $\widetilde{R}^{(c)}$.
$$
R\hat{\alpha}^{(c)}=r^{(c)}
$$

$$
\hat{y}^{(c)}=T\hat\alpha^{(c)}
$$

### Post-processing

We additionally perform a temporal accumulation to aid the reduction of "blockiness".

## Feature Buffer Selection

We adopt the following multi-order set of feature buffers:
$$
T=[1,n_x,n_y,n_z,w_x,w_y,w_z,w_x^2,w_y^2,w_z^2]
$$

## GPU Implementation

The block size was chosen to be $32\times32$.